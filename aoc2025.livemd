# aoc 2025

## Library

```elixir
defmodule AOC do
  # int("123") = 123
  def int(s), do: String.to_integer(s)

  # str(123) = "123"
  def str(x), do: to_string(x)

  # dup(1, 3) -> [1,1,1]
  def dup(x, n), do: for(_ <- 1..n//1, do: x)

  # int2d("1 2 3\n4 5 6") = [[1,2,3], [4,5,6]]
  def int2d(s, sep \\ ~r/[^\d]+/) do
    String.split(s, "\n", trim: true)
    |> Enum.map(fn s -> for i <- String.split(s, sep), i != "", do: int(i) end)
  end

  # mod(5, 3) = 2
  def mod(a, b), do: Integer.mod(a, b)

  # divmod(5, 3) = {1, 2}
  def divmod(a, b), do: {div(a, b), mod(a, b)}

  def puts(s), do: IO.puts(inspect s, printable_limit: :infinity) && s

  def putm(m) do
    for({{h, w}, _} <- [Enum.max m], i <- 0..h, do: IO.puts(for j <- 0..w, do: m[{i, j}])) && m
  end

  def s2map(s) do
    for {r, i} <- String.split(s, "\n", trim: true) |> Enum.with_index(),
        {c, j} <- String.to_charlist(r) |> Enum.with_index(),
      into: %{}, do: {{i, j}, c}
  end

  def add2({x, y}, {u, v}), do: {x + u, y + v}
  def sub2({x, y}, {u, v}), do: {x - u, y - v}
  def mul2({x, y}, k), do: {x * k, y * k}
  def l1norm({x1, y1}, {x2, y2}), do: abs(x1 - x2) + abs(y1 - y2)
  def dir4(), do: [{1, 0}, {0, 1}, {-1, 0}, {0, -1}]
  def dir8(), do: [{-1, -1}, {-1, 0}, {-1, 1}, { 0, -1}, { 0, 1}, { 1, -1}, { 1, 0}, { 1, 1}]
  def move(p, ds \\ dir4()), do: for(d <- ds, do: add2(p, d))
  def set(enum \\ []), do: MapSet.new(enum)

  defmacro cache(key, do: expr) do
    quote do
      Process.get(unquote(key)) || unquote(expr) |> tap(&Process.put(unquote(key), &1))
    end
  end

  # connected components
  def cc(g, ps \\ [], c \\ set(), cs \\ [])
  def cc(g, [], c, cs) do
    case Enum.take(g, 1) do
      [] -> [c | cs]
      [{p, e}] -> cc(Map.delete(g, p), e, set([p]), [])
    end
  end
  def cc(g, [p|ps], c, cs) do
    case Map.pop(g, p) do
      {nil, g} -> cc(g, ps, c, cs)
      {e, g} -> cc(g, e ++ ps, MapSet.put(c, p), cs)
    end
  end

  # keyword to graph [{k,v}] -> %{k => [v]}
  def k2g(ks) do
    for {p, q} <- ks, {p, q} <- [{p, q}, {q, p}], reduce: %{} do
      g -> Map.update(g, p, [q], &[q | &1])
    end
  end

  def str2d(s, r1 \\ ~r/\n/, r2 \\ ~r/\W+/) do
    for s <- String.split(s, r1, trim: true), do: String.split(s, r2, trim: true)
  end
end
```

## 2025

```elixir
defmodule Day1 do
  import AOC
  def part1(input) do
    for [s] <- input |> str2d(), reduce: {50, 0} do
      {dial, count} ->
        {d, n} = String.split_at(s, 1)
        sign = d == "R" && 1 || -1
        n = int(n)
        dial = mod(dial + sign * n, 100)
        count = count + (dial == 0 && 1 || 0)
        {dial, count}
    end
    |> elem(1)
  end
  def part2(input) do
    for [s] <- input |> str2d(), reduce: {50, 0} do
      {dial, count} ->
        {d, n} = String.split_at(s, 1)
        sign = d == "R" && 1 || -1
        n = int(n)
        dial2 = mod(dial + sign * n, 100)
        dist = sign > 0 && 100 - dial || (dial == 0 && 100 || dial)
        m = n - dist
        count2 = count + (m > 0 && div(m, 100) + 1 || 0) + (m == 0 && 1 || 0)
        {dial2, count2}
    end
    |> elem(1)
  end
end

input = "L68\nL30\nR48\nL5\nR60\nL55\nL1\nL99\nR14\nL82\n"

Day1.part1(input) |> IO.inspect(label: :day1_part1)
Day1.part2(input) |> IO.inspect(label: :day1_part2)
```

```elixir
defmodule Day2 do
  import AOC
  def part1(input) do
    input
    |> str2d(",", "-")
    |> Enum.flat_map(fn [a, b] -> int(a)..int(b) end)
    |> Enum.filter(fn s ->
      s = str(s)
      n = String.length(s)
      {a, b} = String.split_at(s, div(n, 2))
      a == b
    end)
    |> Enum.sum()
  end
  def part2(input) do
    input
    |> str2d(",", "-")
    |> Enum.flat_map(fn [a, b] -> int(a)..int(b) end)
    |> Enum.filter(&repeat(to_charlist(&1), 1) > 1)
    |> Enum.sum()
  end
  def repeat(cs, n) when length(cs) == n, do: 1
  def repeat(cs, n) do
    Enum.chunk_every(cs, n)
    |> Enum.uniq()
    |> case do
      [_] -> div(length(cs), n)
      _ -> repeat(cs, n + 1)
    end
  end
end

input = "11-22,95-115,998-1012,1188511880-1188511890,222220-222224,1698522-1698528,446443-446449,38593856-38593862,565653-565659,824824821-824824827,2121212118-2121212124"

Day2.part1(input) |> IO.inspect(label: :day2_part1)
Day2.part2(input) |> IO.inspect(label: :day2_part2)
```

```elixir
defmodule Day3 do
  import AOC
  def part1(input) do
    input
    |> int2d("")
    |> Enum.sum_by(&find(&1, 2, 0))
  end
  def part2(input) do
    input
    |> int2d("")
    |> Enum.sum_by(&find(&1, 12, 0))
  end
  def find(_, 0, r), do: r
  def find(a, n, r) do
    {d, i} = Enum.slice(a, 0..-n//1) |> Enum.with_index() |> Enum.max_by(&elem(&1, 0))
    Enum.slice(a, i+1..-1//1) |> find(n - 1, r * 10 + d)
  end
end

input = "987654321111111\n811111111111119\n234234234234278\n818181911112111"

Day3.part1(input) |> IO.inspect(label: :day3_part1)
Day3.part2(input) |> IO.inspect(label: :day3_part2)
```

```elixir
defmodule Day4 do
  import AOC
  def part1(input) do
    input |> s2map() |> find() |> length()
  end
  def part2(input) do
    input |> s2map() |> solve2(0)
  end
  def find(m) do
    for({p, c} <- m, c == ?@, length(for d <- dir8(), m[add2(p, d)] == ?@, do: 1) < 4, do: p)
  end
  def solve2(m, acc) do
    case find(m) do
      [] -> acc
      ps -> for(p <- ps, reduce: m, do: (m -> %{m | p => ?.})) |> solve2(acc + length(ps))
    end
  end
end

input = "..@@.@@@@.\n@@@.@.@.@@\n@@@@@.@.@@\n@.@@@@..@.\n@@.@@@@.@@\n.@@@@@@@.@\n.@.@.@.@@@\n@.@@@.@@@@\n.@@@@@@@@.\n@.@.@@@.@.\n"

Day4.part1(input) |> IO.inspect(label: :day4_part1)
Day4.part2(input) |> IO.inspect(label: :day4_part2)
```
